using System;

public class Camera
{
	//TODO: Use transform
	public Vector2 Offset { get; set; }

	public Camera(Vector2 offset)
	{
		this.Offset = offset;
	}
}

public class MathUtil
{
	public static float Normalize(float min, float max, float val)
	{
		return (val - min) / (max - min);
	}

	public static float Lerp(float a, float b, float t)
	{
		return a + t * (b - a);
	}
}

public class Transform
{
	//TODO: Have a Camera that can be set and modified on the transform

	public float x { get { return position.x; } set { position.x = value; } }
	public float y { get { return position.y; } set { position.y = value; } }

	public Vector2 position { get; set; }

	/// <summary>In degrees</summary>
	public float rotation { get; set; }
	/// <summary>Offset from top left from 0-1.0 where 1.0 is the pixel width of the texture</summary>
	public Vector2 center { get; set; }
	public float scale { get; set; }
	
	/// <summary>
	/// Using floats where 1.0 is the true width of the texture
	/// </summary>
	public Vector2 size { get; set; }
	public Vector2 actualSize { get; set; }

	public Transform()
	{
		position = new Vector2();
		rotation = 0;
		center = new Vector2();
		scale = 1;
		size = new Vector2();
		actualSize = new Vector2();
	}

	public Transform(Transform other)
	{
		position = new Vector2(other.position);
		rotation = other.rotation;
		center = new Vector2(other.center);
		scale = other.scale;
		size = new Vector2(other.size);
		actualSize = new Vector2(other.actualSize);
	}

	public void Translate(float x, float y)
	{
		Translate(new Vector2(x, y));
	}

	public void Translate(Vector2 translation)
	{
		this.position += translation;
	}

	public void Rotate(float degrees)
	{
		rotation += degrees;
	}

	/// <summary>Width and height is the full width of the transform. So 1.0 size if width pixels</summary>
	public Rectangle GetHitbox()
	{
		Vector2 transformedPos = DoTransform();
		Vector2 transformedSize = new Vector2(
			size.width * actualSize.width,
			size.height * actualSize.height
		);
		return new Rectangle(transformedPos, transformedSize);
	}

	public Vector2 DoTransform()
	{
		float s = (float)Math.Sin((Math.PI / 180.0) * rotation);
		float c = (float)Math.Sin((Math.PI / 180.0) * rotation);
		Vector2 rot = new Vector2(s, c);

		/*Vector2 newPos = new Vector2(
			result.x * c - result.y * s,
			result.x * s + result.y * c
		);*/
		Vector2 newPos = new Vector2();

		newPos += position;

		return newPos;
	}
}

public class Rectangle
{
	public Vector2 min;
	public Vector2 max;

	public Rectangle(Vector2 pos, Vector2 size)
	{
		min = new Vector2(pos.x, pos.y);
		max = new Vector2(pos.x + size.x, pos.y + size.y);
	}

	public bool Intersects(Rectangle other)
	{
		return !(
			max.x < other.min.x ||
			max.y < other.min.y ||
			min.x < other.max.x ||
			min.y < other.max.y
		);
	}
}

public class Vector2
{
	public float x { get; set; }
	public float y { get; set; }
	public float width { get { return x; } set { x = value; } }
	public float height { get { return y; } set { y = value; } }

	public Vector2()
	{
		x = y = 0;
	}

	public Vector2(float x, float y)
	{
		this.x = x;
		this.y = y;
	}

	public Vector2(Vector2 other)
	{
		this.x = other.x;
		this.y = other.y;
	}

	public void Add(float x, float y)
	{
		this.x += x;
		this.y += y;
	}

	public void Sub(float x, float y)
	{
		this.x -= x;
		this.y -= y;
	}

	public void Mul(float x, float y)
	{
		this.x *= x;
		this.y *= y;
	}

	public void Mul(float v)
	{
		this.x *= v;
		this.y *= v;
	}

	public void Div(float x, float y)
	{
		this.x /= x;
		this.y /= y;
	}

	public void Div(float v)
	{
		this.x /= v;
		this.y /= v;
	}

	public float Length()
	{
 		return (float) Math.Sqrt(x * x + y * y);
	}

	public void Normalize()
	{
		var length = Length();
		x /= length;
		y /= length;
	}

	public Vector2 Normalized()
	{
		var length = Length();
		return new Vector2(x/length, y/length);
	}

	public bool Equals(Vector2 other)
	{
		return this == other;
	}

	public static bool operator!=(Vector2 a, Vector2 b)
	{
		return !(a == b);
	}

	public static bool operator==(Vector2 a, Vector2 b)
	{
		float x = Math.Abs(a.x - b.x);
		float y = Math.Abs(a.y - b.y);

		return (x < 1e-4 && y < 1e-4);
	}

	public static Vector2 Lerp(Vector2 a, Vector2 b, float t)
	{
		return a + t * (b - a);
	}

	public static float Distance(Vector2 a, Vector2 b)
	{
		return (a - b).Length();
	}

	public override int GetHashCode()
	{
		// Generated by vs so /shrug.
		// A simple x^y would probably work
		var hashCode = 1502939027;
		hashCode = hashCode * -1521134295 + x.GetHashCode();
		hashCode = hashCode * -1521134295 + y.GetHashCode();
		return hashCode;
	}

	public override string ToString()
	{
		return "{ x = " + x + ", y = " + y + " }";
	}

	public override bool Equals(object obj)
	{
		return base.Equals(obj);
	}

	public static Vector2 operator+(Vector2 a, Vector2 b)
	{
		return new Vector2(a.x + b.x, a.y + b.y);
	}

	public static Vector2 operator -(Vector2 a, Vector2 b)
	{
		return new Vector2(a.x - b.x, a.y - b.y);
	}

	public static Vector2 operator *(Vector2 a, Vector2 b)
	{
		return new Vector2(a.x * b.x, a.y * b.y);
	}

	public static Vector2 operator *(Vector2 a, float v)
	{
		return new Vector2(a.x * v, a.y * v);
	}

	public static Vector2 operator *(float v, Vector2 a)
	{
		return new Vector2(a.x * v, a.y * v);
	}

	public static Vector2 operator /(Vector2 a, Vector2 b)
	{
		return new Vector2(a.x / b.x, a.y / b.y);
	}


}
